pragma language_version >= 0.17;

import CompactStandardLibrary;


// #region Ledger States

// Global poll counter (monotonically increases with each new poll).
export ledger pollId: Counter;

// Map of pollId → creator’s hashed identity.
export ledger pollOwners: Map<Field, Field>;

// Map of pollId → questionId → question text (stored as Field).
export ledger questions:  Map<Field, Map<Field, Bytes<250>>>;
export ledger questionsInPoll: Map<Field, Counter>;

// Map of pollId → questionId → optionId → option text.
export ledger options:    Map<Field, Map<Field, Map<Field, Bytes<100>>>>;
export ledger optionsInQuestions: Map<Field, Counter>;

// Map of pollId → questionId → optionId → number of votes received.
export ledger optionVotesReceived:   Map<Uint<64>, Map<Uint<64>, Map<Uint<64>, Counter>>>;

// Map of pollId → questionId → total number of votes (handy for validation).
export ledger questionVotesRecieved: Map<Uint<64>, Map<Uint<64>, Counter>>;

// Tracks whether a user has already voted on a given poll/question.
// Uses tag = PRF(secret, pollId, questionId).
// pollId → questionId → userTag → number of votes (should normally be 0 or 1).
export ledger userVoteCounts: Map<Uint<64>, Map<Uint<64>, Map<Field, Uint<32>>>>;

// Stores cryptographic receipts for votes if needed.
// pollId → questionId → userTag → proof/receipt.
export ledger voteReceipts: Map<Uint<64>, Map<Uint<64>, Map<Field, Field>>>;

// Tracks whether a user has already claimed a reward for voting.
// Presence of a Unit value means “already claimed.”
// pollId → questionId → userTag → claimed marker.
export ledger rewardClaims: Map<Uint<64>, Map<Uint<64>, Map<Field, Boolean>>>;

// #endregion 

// #region Witnesses

// Retrieve the caller’s local secret (unique to each wallet/device).
witness getLocalSecret(): Bytes<32>;

// Retrieve the caller’s shared secret (used for approvals/consent).
witness getSharedSecret(): Bytes<32>;

// #endregion

// #region Write circuits
// Create poll circuit: assigns a new pollId and records its owner.
export circuit createPoll(): [] {
    const tag = pad(32, "new poll");
    const creatorKey = ownPublicKey();

    // Safety check: creator must not be empty.
    assert (creatorKey != default<ZswapCoinPublicKey>, "Creator cannot be empty");

    // Derive a hashed identity key for the creator using their public key
    // and their private local secret, then disclose it.
    const creatorHashKey = disclose(generateHashKey(tag,creatorKey.bytes, getLocalSecret()));

    // Increment global poll counter to generate new pollId.
    pollId.increment(1);
    const pollIdHash = disclose(generatePollIdHashKey(tag, pollId, getLocalSecret()));

    // Store the poll owner’s identity hash against this pollId.
    pollOwners.insert(pollIdHash, creatorHashKey);
    // Instantiating a spot for the first question.
    questionsInPoll.insert(pollIdHash, default<Counter>);
}

export circuit createQuestion(pollIdHash: Field, question: Bytes<250>): [] {
    const tag = pad(32, "question");
    const creatorKey = ownPublicKey();

    assert(creatorKey != default<ZswapCoinPublicKey>, "Creator cannot be empty");
    assert(pollIdHash != default<Field>, "Poll ID cannot be empty");
    assert(question != default<Bytes<250>>, "Question cannot be empty");

    const questionIdHash = disclose(generateQuestionIdHashKey(tag, question, pollIdHash, getLocalSecret()));
    const pubPollId = disclose(pollIdHash);

    //Insert questions into the ledger by first creating a record with the pollIdHash
    questions.insert(pubPollId, default<Map<Field, Bytes<250>>>);
    //Next look up the pollIdHash that we just inserted and insert the question hash and question text into the map.
    questions.lookup(pubPollId).insert(questionIdHash, disclose(question));
    // Increase the counter for the questions in the poll
    const questionCount = questionsInPoll.lookup(pollIdHash).read();
    questionsInPoll.lookup(pollIdHash).increment(1);
}

export circuit createOption(pollIdHash: Field, questionIdHash: Field, option: Bytes<100>): [] {
    const tag = pad(32, "new option");
    const creatorKey = ownPublicKey();
    
    assert(creatorKey != default<ZswapCoinPublicKey>, "Creator cannot be empty");
    assert(pollIdHash != default<Field>, "Poll ID cannot be empty");
    assert(questionIdHash != default<Field>, "Question ID cannot be empty");
    assert(option != default<Bytes<100>>, "Option cannot be empty");
    
    const optionIdHash = disclose(generateOptionIdHashKey(tag, option, questionIdHash, getLocalSecret()));
    options.lookup(pollIdHash).lookup(questionIdHash).insert(optionIdHash, disclose(option));
    optionsInQuestions.lookup(questionIdHash).increment(1);
}

// #endregion

// #region Data structures for reading onchain data.

struct PollData {
    pollIdHash: Field, 
}

struct QuestionData {
    pollIdHash: Field,
    questionIdHash: Field,
    question: Bytes<250>
}

struct OptionData {
    pollIdHash: Field,
    questionIdHash: Field,
    optionIdHash: Field,
    option: Bytes<100>
    
}

// #endregion

// #region Read circuits
export circuit questionCount(pollIdHash: Field): Uint<64> {
    assert(pollIdHash != default<Field>, "Poll Id cannot be empty.");
    
    const questionCount = questionsInPoll.lookup(pollIdHash).read();
    
    return questionCount;
}

export circuit questionRead(pollIdHash: Field): Bytes<250> {
    assert (pollIdHash != default<Field>, "Poll Id cannot be empty");

    const questionData = default<QuestionData>;

    // questions.lookup(disclose(pollIdHash)).lookup(
    
    // )
    return questionData.question;

}

// #endregion

// #region Helper Circuits

// Generate a hashed identity key (pseudo-random identifier)
// by hashing together two 32-byte values (typically pubkey and secret).
export pure circuit generateHashKey(tag: Bytes<32>, pK1: Bytes<32>, pK2: Bytes<32>): Field {
    return transientHash<[Bytes<32>, Bytes<32>, Bytes<32>]>([tag, pK1, pK2]);
}

export pure circuit generatePollIdHashKey(tag: Bytes<32>, pollId: Uint<64>, pK1: Bytes<32>): Field {
    return transientHash<[Bytes<32>, Uint<64>, Bytes<32>]>([tag, pollId, pK1]);
}

export pure circuit generateQuestionIdHashKey(tag: Bytes<32>, question: Bytes<250>, pollIdHash: Field, pK1: Bytes<32>): Field {
    return transientHash<[Bytes<32>, Bytes<250>, Field, Bytes<32>]>([tag, question, pollIdHash, pK1]);
}

export pure circuit generateOptionIdHashKey(tag: Bytes<32>, option: Bytes<100>, questionIdHash: Field, pK1: Bytes<32>): Field {
    return transientHash<[Bytes<32>, Bytes<100>, Field, Bytes<32>]>([tag, option, questionIdHash, pK1]);
}

// #endregion